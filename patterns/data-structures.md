# Data Structures

# Common Data Structures in Coding Interview Problems

## Primitive Types [10]

Know how int, char, double, floating point etc. are represented in memory and
the primitive operations on them.

## Hash Table [5][6][7]

- What is a hash table? Why do we use it?
  - Data structure used to store key-value pairs that supports the following
    operations: `insert(key,val)`, `delete(key)` and `search(key)`. To store a
    key-value pair using array with chaining, a function is used to create a
    hash code for the key, then another function uses this hash code to map to
    an index of an array, where there is a linked list with nodes containing
    key-value pairs;
- What is hashing?
  - Hashing is the operation of computing an integer (hash code) from a key
    (usually string). The key is divided into pieces and mixed up to provide
    randomization;
- What is the time complexity associated with these operations?
  - Implementation with AVL tree has `O(log(n))` time for `insert`, `delete` and
    `search`. Implementation with array and chaining has `O(1)` time for
    `insert`, `delete` and `search`;
- What are some applications of hash tables?
  - docdist, databases, store a dictionary in any language, spelling correction,
    compilers & interpreters (variable to memory address), substring search;
- What are collisions and how they happen? How to deal with collisions?
  - Collisions happen when two or more keys have the same hash code, or have
    different hash codes that map to the same index in the array. It happens
    because considering keys are strings, there is an infinite number of keys
    for a finite number of hash codes and indexes;
  - Strategies to deal with collisions:
    - Chaining: store a linked list in which nodes contain the key and the value
      on each array index. When collisions happen, add new nodes to the list. To
      search for a key, traverse the linked list until you find the node with
      the target key;
    - Open adressing: only at most one item is present on each array index.
      Because probing is used, when a collision happens, new hash code and index
      are computed until an empty index is found;
- What is a good hashing function?
  - A good hashing function minimizes the number of collisions for all possible
    keys;
  - Examples of hash functions:
    - Division method: `h(k)=k mod m` . Good if m is prime and away from powers
      of 2 or 10;
    - Multiplication method: `h(k)=[(a*k) mod 2^w]>>(w-r)`, where `a` should be
      an add integer away from powers of 2 and `r` is anpther chosen integer;
- If all keys go to the same hash value, O(1) search is violated using chaining.
  How to still achieve it?
  - It is possible to achieve it using probing. Compute hash value and attempt
    insert. If the slot is occupied, compute a new hash value until finds an
    empty slot. Because the number of slots (m) is greater than the number of
    pairs inserted (n), it will be found eventually;
  - Probing has a well defined order of attempt to insert each key. So, if keys
    are replaced with `None` when deleted, `search` would return not found
    incorrectly. To solve the issue, `delete_me` flags are used, which are
    treated as "keep looking" by `search`, but treated the same as `None` by
    `insert`;
  - Probing strategies:
    - Linear probing: `h(k,i)=(h'(k)+i) mod m` works well with permutation, but
      generates clustering (growing groups of occupied slots);
    - Double hashing: `h(k,i)=(h1(k)+i*h2(k)) mod m`, where h2(k) is relative
      prime to m to have a permutation. Does not have problems of Linear
      Probing;

## Sequence (Array, String or Linked List)

- Array[10]: advantage is fast access for an element at an index. Disadvantages
  is slow lookups if unsorted and insertions. Understand iteration, resizing,
  partitioning and merging;
- String[10]: know how strings are represented in memory. Understand basic
  operations such as iteration, comparison, copying, matching, joining,
  splitting and reversing;
- Linked list[10]: know trade-offs with respect to arrays. Understand operations
  such as iteration, insertion and deletion for singly and doubly linked list.
  Know how to implement them using dynamic allocation and arrays;
- Subsequence[1][4]: subset of the original structure which follow the original
  ordering of elements. All subsequences are subsets, but the reverse is not
  true. All subsequences can be generated by choosing to add or not each element
  to the existing subsequences on the ordered structure. Identify: problem
  mentions subsequences or just deals with structures where the ordering of
  elements matters but not all elements might be present. E.g. BST Sequences,
  Longest consecutive subsequence, Alien Dictionary;
- Subarray/substring/sublist[1][4]: contiguous subsequence of the original
  structure. All subarrays/substrings/sublists are subsequences, but the reverse
  is not true. They can be generated by scanning the original structure with a
  sliding window and at each index expanding it until one reaches the end.
  Identify: problem mentions subarray/substring/sublist or just deals with
  structures where the ordering of elements matters and they must be
  side-by-side on the original structure. E.g. Letter and Numbers, Shortest
  Supersequence, Maximum Sub Subarray;
- Set[1]: unordered collection of elements without duplicates. Add, remove and
  verify presence of elements is O(1) time. It is not possible to iterate over
  using an index;

## Stack[1]

- Definition: data structure that follows the Last In First Out rule. Used to
  implement recursion (recursive call stack), recursive algorithms iteratively,
  reverse input, check balanced parentheses and store elements previously seen
  for future computation.
- Operations:
  - Push: add element to top of the stack. O(1) time and O(1) space;
  - Pop: remove and return element from the top of the stack. O(1) time and O(1)
    space;
  - Peek: return element from the top of the stack. O(1) time and O(1) space;
  - isEmpty: return boolean to indicate if the the stack is empty. O(1) time and
    O(1) space;
- Implementation: usually implemented with an array or linked list;
- Identify: problem involves recursion, reverse or turn upside down the input,
  balance parentheses or it is convenient to access the elements already seen in
  reverse order. E.g.: Binary Tree Upside Down, Check for balanced parentheses,
  Depth-first Search, Largest Rectangle in Histogram, Convert Multi-level Linked
  List into Singly Linked List;

## Queue[1][2][3]

- Definition: data structure that follows the First In First Out rule. Used to
  hold nodes to be processed in Breadth-first Search, task scheduling, or
  organize access to shared resource.
- Operations:
  - Add: add element to the back of the queue. O(1) time and O(1) space;
  - Remove: remove and return element from the front of the queue. O(1) time and
    O(1) space;
  - Peek: return element from the front of the queue. O(1) time and O(1) space;
  - isEmpty: return boolean to indicate if the the queue is empty. O(1) time and
    O(1) space;
- Implementation: usually implemented with an array or linked list;
- Identify: problem involves Breadth-first Search or task scheduling. E.g.: Task
  Scheduler, Shortest Subarray with Sum at Least K, Rotting Oranges;

## Heap or Priority Queue [1]

- Definition: priority queue is a queue where the element with highest priority
  reaches the front first.
- Operations (n is the number of elements in the priority queue):
  - Add: add element to the priority queue. O(log(n)) time and O(1) space;
  - Remove: remove and return element from the priority queue. O(log(n)) time
    and O(1) space;
  - Peek: return element from the front of the priority queue. O(1) time and
    O(1) space;
  - isEmpty: return boolean to indicate if the the priority queue is empty. O(1)
    time and O(1) space;
- Implementation: usually implemented with a heap;
- Identify: problem involves Dijkstra's Algorithm or a non-standard processing
  order of elements based on a certain property. E.g. Cheapest Flights Within K
  Stops, Meeting Rooms II;

## Tree

- Tree[1][10]: undirected connected acyclic graph. A binary tree is a tree whose
  nodes have up to two children, used to represent hyerarchical data.
  - Root: tree node that has no parent;
  - Leaf: tree node that has no children;
  - Depth: level of a note relative to the root of the tree;
  - Height: maximum depth of any node in the tree;
  - Traversals: particular order of visiting all nodes in the tree;
  - Predecessor: node which comes before in a particular traversal;
  - Sucessor: node which comes after in a particular traversal;
  - Binary Search Tree: binary tree with numbers in nodes such that
    `left_children<=current_node<=right_children`;
    - Advantages: if balanced, offers O(log(n)) time insertion, deletion,
      lookup, find min or max, sucessor and predecessor;
    - Understand node fields and pointers;
    - Understand balance and operations maintaining it;
    - Know how to augment a BST, like interval trees and dynamic kth largest;
- Trie[1]: N-ary tree with one character or number on each node, with boolean
  flags representing the end of a sequence. It can verify in linear time if a
  sequence is a prefix of any complete sequence, or search for a sequence with a
  given prefix. Identify: the problem input is a list of words, a board of
  characters or phone numbers and one must find, replace or count all sequences
  with a given prefix or suffix. E.g. Word Search II (Leetcode), Replace Words
  With Prefix, Prefix and Suffix;
- Heap[1]: a min-heap is a complete binary tree where each node is smaller than
  its children, such that the root is the smallest element of the tree. A
  max-heap is equivalent but with the root as the largest element in the tree. A
  heap is usually implemented using an array;

## Graph

- Graph[1][8][9]: collection of nodes with edges between some of them. Essential
  representations in memory (v=number of vertex, e=number of edges):
  - Matrix: grid[i][j]=1 indicates edge from node i to node j. It can also hold
    the weight of the edge in the cell;
    - Pros: removing an edge and edge queries take O(1) time;
    - Cons: takes up more space, O(v^2);
  - Adjacency List: an array of lists is used, where mapping[i] is a list of all
    outward neighbors of node i. Weight of edges are paired with nodes;
    - Pros: takes up little space, O(v+e), and adding a vertex is easy;
    - Cons: edge queries take long, O(v) time;
  - Objects and Pointers: a node object is created, which contains some data and
    a list of pointers to all its neighbors, outwards. Weight of the edges can
    be paired with pointers;
    - Pros: reduce space usage by removing duplicated edges from adjacency list,
      O(v+e) space. More intuitive representation;
    - Cons: edge queries take long, O(e) time, worst case is O(v^2);

# References

[1] McDowell, Gayle L. - Cracking the Coding Interview, 6th Edition, 2019.

[2] Coding Freak - Queue Data Structure Practice Problems and Interview Questions, 2018.
<https://medium.com/@codingfreak/queue-data-structure-practice-problems-and-interview-questions-f459bf0578db>

[3] Geeks for Geeks - Applications of Priority Queue, 2018.
<https://www.geeksforgeeks.org/applications-priority-queue/>

[4] Geeks for Geeks - Subarray/Substring vs Subsequence and Programs to Generate them, 2015.
<https://www.geeksforgeeks.org/subarraysubstring-vs-subsequence-and-programs-to-generate-them/>

[5] MIT OpenCourseWare - 8. Hashing with Chaining, 2011.
<https://www.youtube.com/watch?v=0M_kIqhwbFo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=8>

[6] MIT OpenCourseWare - 9. Table Doubling, Karp-Rabin, 2011.
<https://www.youtube.com/watch?v=BRO7mVIFt08&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=9>

[7] MIT OpenCourseWare - 10. Open Addressing, Cryptographic Hashing, 2011.
<https://www.youtube.com/watch?v=rvdJDijO2Ro&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=10>

[8] Geeks for Geeks - Graph and its representations, 2020.
<https://www.geeksforgeeks.org/graph-and-its-representations/>

[9] Stack Overflow - Object and Pointer Graph representations, 2015.
<https://stackoverflow.com/questions/27809894/object-and-pointer-graph-representations>

[10] Adnan Aziz - Elements of Programming Interviews, 2014.
